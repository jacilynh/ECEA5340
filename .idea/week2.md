#Week 2#

1: PSOC Creator, Introduction and Documentation

In order to learn about embedding sensors and actuators, we're going to need some sort of development kit. There are dozens of them out there, and lots of them are very good. Each has certain capabilities and for this specialization, we've chosen the Cypress PSoC. 

There's good reason for that because the Cyprus PSoC is a true mixed signal development kit. That means you can have analog inputs, and you can process the analog inputs using analog components. Like op amps and comparators, and sample and hold. In addition to having digital components, such as timers and counters all inside the same chip.

There are plenty of microcontrollers out there that have analog inputs, and have A to D converters. What's different about the Cypress chip, and this is an important point, is that you get to arbitrarily wire up the components in any circuit topology you want. You're not stuck with what you got from the manufacturer. That makes it particularly useful and flexible for teaching.

What I like particularly about this development kit is that the Cypress software allows you to work on both the schematic. And the code that interacts with all the components on the schematic and in the chip all in one design environment. It's all very tightly coupled, I think it's pretty well written, and I think you can learn how to use it in about 15 minutes. Of course Cypress Corporation has a pretty comprehensive set of training videos online where you can learn everything there is to know about this chip. But for this specialization, I want to concentrate on embedding sensors and actuators, so we'll just cover a subset of that. Anything that I say here you can certainly go to the Cypress website and find more information about it.

So why am I bothering to teach you about PSoC when you can find out everything you need to know on the Cypress website?

Really it's a matter of emphasis. Cypress's goal is of course, to teach you everything there is to know about the chip, whereas my goal is just to teach you enough for this course.

When you first start PSoC Creator, you'll get a window that looks something like this. There are several major sections in this window that we need to talk about. Of course, there's the usual menus at the top and a few hot keys. Over here on the left is an area that we call Workspace Explorer. And once we start a project, all the files that are related to that project, and there will be many separate files, they'll show up over here. To begin, after bringing up this window, we just go to File, click on New > Project.

And the first question it asks is what type of device you have. And here because I've used this before, I've already made sure that it points to PSoC 5LP, which is the family of device we have.

Followed by the particular part number, and if you look closely on your development kit you'll see this exact number. This is the exact model number of the chip that we will be using. So you have to make sure that both those boxes are correctly filled out before you continue. This software works with many different types of Cypress chips. And we have to make sure that the code that's produced is compatible with the chip that we have. So we have the CY8C5888LTI-LP097, that refers to the chip, not the development kit itself. The development kit is the chip on the board with some other circuitry.

Once you're satisfied that you've correctly picked the target, don't worry about Library project or Workspace. We'll just hit Next, and click on Empty schematic, going to click here. And go to Next again, and now we come to arbitrary names for Workspace, or Project.

And you can leave those alone, or you can put in any name you want. So for now I'll just leave it as Workspace03, and Project is Design01.

The Project file really contains all the files that are necessary to build your design. And the Workspace is a much smaller file that just points to different Projects. The idea being that you can have several Projects grouped in a Workspace if they're somehow related.

Next step is to click Finish and wait a second, and now you get this very interesting screen. Like many Windows based development environments, this screen can be rearranged. But let's assume for a minute that you leave it in the original configuration.

There are five main sections that we need to talk about. We've already mentioned here on the left side, we have the Workspace Explorer. And if you look carefully at that, you'll see the name of the Workspace that you selected previously, and underneath that a particular design. Notice that Design01 is in bold which indicates that your active design, you could have more than one here.

And beneath that are a bunch of files and line items such as Pins, Analog, Clocks, Interrupts. We're only going to need to deal with a couple of those. That's why I can teach you this in 15 minutes rather than the many hours it would take to cover everything.

Very importantly in the Workspace Explorer, right down there at the bottom under source files, you'll see main.c. That's an example of automatically generated code. If we click on that, it will take you to an outline for the base file of any c project which is called main.c. And that simply contains a few comments and a couple of lines of code that you would want to include with any project. Most importantly being project.h which defines all the details of the chip that you are dealing with.

Going back to the overall PSoC Creator screen, right there in center we see a blank schematic.

This is where you'll build circuitry that interacts with the code that you write which is just a click away.

At the top of the schematic area are a list of tabs and that's your most recently used tab list. Every time you click on something PSoC Creator will remember that you clicked on it. And it'll put a tab up there so that you can get back to it quickly.

Below the Workspace Explorer section in the default view is the output window. The output window shows you a bunch of cryptic messages as your project is compiled or built. But the last message is usually pretty clear, it will be obvious whether or not the build worked or didn't work.

For instance, in this example it clearly says Build Succeeded.

Moving to the right side of the screen in the default view is the Component Catalog. This is a list of all the different parts that actually exist inside the PSoC Creator chip that you can arbitrarily wire up in any pattern you see fit. And it's quite a list, let's take a look. I'll expand the Analog tab by clicking on that little plus sign. And we immediately see that there's a category for Analog to Digital Converters, Amplifiers, Multiplexers, Comparators, DACs Mixes and Sample and Hold, all sorts of different things. If I further expand the ADC you'll see that there are three different types of ADCs that you can have inside this chip. Let me see if I can make that a little bit bigger to show it better.

Scrolling down further, under the Digital tab.

We see functions like Counters, and PWM generators, timers and so on common digital functions. Under Logic, it can be as simple as an And gate, or a D Flip Flop. Or even just a source for a Logic High or a Logic Low. All of these components exist inside the PSoC chip, and you get to wire them up as you see fit, it's very flexible.

By now you're probably wondering, how does one make the physical connection to a pin on the chip from something that's on the schematic. That's actually quite easy to do, and I'll show you in just a few seconds here how it's done. Let's start by taking a Digital Output Pin and putting it on the board.

This name here is completely arbitrary, it does not imply that this pin is actually connected to Pin 1 on the chip.

That I find a little confusing, so I immediately like to reconfigure this and change the name to something like P0_3. Because I intend to connect this pin to Port 0 bit 3. It's not connected to that yet, I've just changed the name. To make the connection, it's quite easy. Just go over here to the Pins tab, and double click on that. And you get this Pin Assignment Window here on the right, and notice that's the name that I chose. And that's a great reminder, because if I use this pull down menu here, I see P0_3 as one of my options. And now I can clearly see the correspondence between the name that I chose and the port number that it's actually assigned to.

That's really all you have to do to assign a pin to a physical location on the chip. It's this Pins tab on the left side.

Hardware Needed to Do Course Project Based on This Module
You will need to buy the following components to do the two course projects based on the videos in this module. Note that if you have already purchased the PSOC 5LP PROTOTYPING KIT, you do not need to buy it again.

These parts may be purchased off the Digikey web site, www. Digikey.com. Or, you may obtain the specs from the site, and purchase them elsewhere.

These are the part numbers typed out, so you can copy and paste them into the Digikey web site:
428-3390-ND
NHD-0216BZ-RN-YBW-ND
570-1229-ND
A105970CT-ND

Note: there have been shortages of the PSOC 5LP prototyping kit on the electronics web sites. If this kit is not available, you can use the CY8CKIT-050 development board instead. It is available on the Digikey web site as part number 428-3184-ND  or on the Mouser web site as 727-CY8CKIT-050B

2: PSoC Creator 2 Pin Assignment

Here's an example of what pins look like on the schematic. I put down 3 pins, the first one is a digital input pin. Notice that the wire going to it is green. PSoC Creator by default uses that color to indicate digital signals, which are never directly connected to analog signals. The second pin in the middle labelled, Pin_2, is a digital output pin. Notice that, in this case, the green wire extends to the right, and there's a little arrow to help you remember that this is, in fact, a digital output. On the bottom, we have Pin_3. That has a yellow wire, it also extends to the right. But analog pins can be both inputs and outputs in PSoC Creator.

When you first place a pin on a PSoC schematic, PSoC Creator gives it a name. However, this name here is completely arbitrary. It does not imply that this pin is actually connected to Pin_1 on the chip.

That, I find a little confusing. So I immediately like to reconfigure this, and change the name to something like P0_3, because I intend to connect this pin to port 0, bit 3. It's not connected to that yet. I've just changed the name. To make the connection, it's quite easy. Just go over here to the Pins tab, and double click on that. And you get this pin assignment window here on the right. And notice, that's the name that I chose. And that's a great reminder, because if I use this pull down menu here,

I see P0[3] as one of my options. And now, I can clearly see the correspondence between the name that I chose and the port number that it’s actually assigned to.

That's really all you have to do to assign a pin to a physical location on the chip. It's this Pins tab on the left side.

3: Automatically Generated Code

Let's talk for a minute about this idea of automatically generated code. It's a big advance in all embedded systems over the last few years. And that is you don't have to write all the code, there is a library of routines that you can pick and choose from. And just put the function call into main.c and use it, without worrying all the driver details for every component in the chip. If we look at the beginning Window of PSoC Creator, and yours might look a little bit different. But if you don't change any of the defaults and you have the 4.0 version of Creator, this is what it looks like. When you start out, on the top there are few tabs. And if you click on the TopDesign.cysch, which means Cypress schematic, you get this blank schematic. Over here on the left side, in the very important Workspace Explorer section, which contains all the files related to your project. You scroll down, you'll see Source Files > main.c. If we click on that, we get a new tab at the top, there it is, says main.c. And we get this outline of main.c, which is just the starting basis for all your code. But there is no other code in here, because we haven't created anything for this project yet.

Let's go back to schematic and try something very simple. Let's find a digital component, some simple digital components, like maybe a counter.

And a counter like that requires a clock input. So I'll go down to system, and I see Clock over here, and I'll drag a Clock out. And notice, the default frequency of the clock is 12 MHz. But like any other component in the system, we can change that. But for now, let's just use 12 MHz. I'm going to hit the W key on my keyboard, which is equivalent to touching the Wire tool there on the upper left, connect those two boxes.

The only other input I see on this counter is a reset input, and you don't want to leave inputs unconnected. Don't do that, it's a bad practice with any logic family. And we don't want to do it here, because we're not really sure what voltage would be created on there. So we're going to deliberately hook that up to something. And if I go find digital logic, interestingly, a Logic Low is just treated like a component in the systems. So I could take a Logic Low here and just connect that up. And this time, instead the use of the W key, I'll just line up the boxes. And now we have created a Counter inside the chip, that we can interact with using the API, or Application Programming Interface, using the API that Cypress will create for us. And stick in this list of files on the left here, after we build the project. In order to build the project, we go to the upper left, and we find that icon that looks like a couple sheets of paper, with a little plus sign. And if we mouse over it, it says Generate Application. It's an unwieldly term, so I use the term Build. If I click on that, it will start to look at this schematic here and say, I see you put down a Counter. So you probably want to have some function calls related to that counter.

And sure enough, a few seconds later, what appears on the left side of the screen underneath the main.c is something called Generated_Source. And I now have C files related to the clock, the counter, and a whole bunch of other things that are in the category called cy_boot. And those are system-wide function calls, most of which you're not interested in except for the delay function.

But let's concentrate on this Counter_1.c file here, what's in there? If I double-click on it, notice we got a tab on the top here, in our Most Recently Used list, says Counter_1.c. And there's a whole bunch of C code in here that we didn't have to write, it was automatically generated, and really that's the point. If you scroll down through this, you'll see all sorts of things that you're glad you didn't have to write, because it takes time.

For instance, here is a function called Counter_1_Enable.

You won't have to use that one, but this one is very important, it's Counter_1_Start. And here's a good example of a key piece of information that is difficult to find, in all of the information that Cypress provides about this chip on your website. This is just something you have to know. ***All components in a chip require a Start() function, with the exception of pins, I think, and other simple components.*** 

But something like a counter, or a timer, or a dock, or an op-amp, you have to Start(). And by Start(), it's not really starting it so much as it is powering it up. In order to save power on the PSoC chip, all the components have individual power controls. And the default is off, so we're going to start this by, I'll just copy this.

I'll go back to main.c, and right after IntEnable, won't worry about that right now, I'll put this start function in there. And in order to make it a function, I have to have a couple of parentheses and a semicolon, that's what makes it legal C.

And I believe it's good practice to put comments in on the fly.

So there's an example of some code that we didn't write, we didn't have to write these lines of code, we just call the function. We copied the guts of it, and we put it in main.c, and I added the parentheses, the semicolon. And so main.c starts by enabling interrupts, which we're not using right now, and then it turns this counter on. What else do we get in the counter? Well, pretty much anything you could imagine that you might want a counter to do, there will be functions to do that.

For instance, if you were in a very low-power situation and you only needed the counter occasionally? You could power it down by using Counter_1_Stop, we won't be doing that here. There's InterruptMude, ReadStatusRegister, there's a lot of stuff in here that if you just started to read it, you would get quickly lost in a lot of minutiae. So I'm going to cut to the chase and show you the stuff that's important. I already showed you the Start function, that's a key function. WriteCounter, you could write a value and start the counter at some specific value, that's certainly a very important function. Of course, you want to be able to read the counter.

Here, you could change the period of the counter. For instance, the counter could be an 8, 16-bit or larger counter, but that doesn't mean it has to count from the maximum value. You could, for instance, set it up to be an 8-bit counter that counts down to 100. Usually, that's done in the Configuration Menu. Here, we go back to the schematic, I right-click, Configure.

And there, I've just created a 8-bit counter that really starts at 100.

And this is probably a good time to mention to you that the counter, as a default, I believe, counts down. And usually you would expect a counter to count up from 0, but most of the counters, the Fixed Function counters in PSoC count down.

Here we have some functions which are grayed-out. The main thing to remember is you have to start it, it's very easy to put a counter on the board and forget to start it.

And the only other function that you'd really be interested in for a simple operation is just to be able to read the counter. So let's do that, I'll copy this and I'll stick it in main.c, I'll put it in the middle of this for loop.

The counter, when you read it, it's probably coming back as a return value, and there it is, a return value of a uint8.

So I need to have some variable to read it into, and I'll call that count_1 =. And of course, in C, you have to declare your variable. So I have to declare this, and I will do that, declare it as a uint 8, and that gets rid of the red box over here. And this is a relatively uncommon case where the PSoC Creator will immediately notify you when you make a mistake. Most mistakes, it won't tell you about until you build the project. And make sure this all works, let's just go back and re-generate it. I'll hit Generate Application, look at the output box down here, it said Build Skipped.

That means that it just created the APIs, and looked at the APIs and schematic that we created, it did not attempt to download the code. If I clicked on this button, it would first look to see if I changed anything. If I had, it would do the Generate, or Build, then it would download. So this is this, plus a download.

This one seemed to work just fine.

So just to review that, we could put a counter on the board with a clock. We noticed that after we did a Generate, that we got Generated_Source code, all of this we did not write. We looked in Counter_1.c, and that's exactly the name we chose on the schematic. So we chose Counter_1, so we got counter 1.C. It created all of these function calls that we can copy and stick in the main.c, and use to manipulate the counter.

That's how automatically generated code works, it saves you a lot of time and is very convenient.

4: Adding the LCD display to the Nscope and Developent Kit

There are many ways to debug an embedded design. Most of you will probably be familiar with a standard debugging tools like those found in piezo-creator and many other IDEs. These allow you to start and stop the code and when the code is stopped you can see what the values of variables are and you can change them. But you can't see what the values of variables are as they change while the code is running without stopping it. In some designs, it's okay to stop it but in others it's not. For instance a motion control system you cannot stop the code or the machine will run away. If you need to see what's happening in the code while it's running. The classic method is simply to write a one or a zero to an output pin connecting that pin to an oscilloscope and comparing it to when other inputs to the system change gives you timing information that is key to debugging. But what if you want to know more than simply when something happens. Another trick people often use is to write a pulse to an output pan and make the width of the pulse indicative of where you are in the code. 

For instance you can write a one microsecond pulse when a sensor gets above some key level and maybe a two microsecond pulse if it saturates. The oscilloscope, n-scope or any other scope that you have available is also a very valuable tool and combined with a D to A converter like this one you can see all sorts of things that are going on in the code while they're happening. That's a very important point. You don't have to stop the code in order to see the output from a D to A converter. Just hook up your nscope to port three bits six in this case and you'll be able to see whatever value is written to that A to D converter. Of course, the values in your code could be any number of data types. They might be thirty two bit integers. They might be unsigned sixteen bit values and your DAC as you might recall only accepts eight bit unsigned integers. It's pretty easy in code to rescale any value that you have in your code to be within the range of an eight bit integer. And here's a simple example of that. Suppose we had a value in the code called noise level. Maybe it's a pretty big number. Maybe the largest value the number if you divide it by sixteen is less than two hundred and fifty five which is the largest eight bit value you can have. So I take that number and divide it by sixteen and then I cast it to an unsigned eight bit integer which is what the DAC requires. And then we write it out to the DAC. Every time you hit this line in the code the DAC will get a new value and you'll be able to see it on your scope and that might happen at a rate that's much faster than you could see with the naked eye, if you were using for instance an LCD display. So what's the point of adding an LCD display if you already have the debugger and you have the oscilloscope. Well, the main reason is that the LCD display allows you to look at variables as they are changing in the code as long as they don't change so rapidly that you can't read the display. Remember the oscilloscope can plot variables and you can plot them as fast as they change maybe thousands tens of thousands of times per second. It's difficult for a human to read an LCD display at a rate faster than twice a second. But there are a lot of variables and code that in fact change that slowly and it's easy to display those. Furthermore you have formatting options you can display them as unsigned integers. You can display them as hex and you can display words around them. So it's a very valuable tool in addition to the tools you have now. Connecting an LCD display such as the two by sixteen New Haven display is pretty straightforward but it does require about ten wires and two resistors. Here's the schematic taken from a different Cypress dev kit. But implies to this one as well with just a few simple changes. Both kids use port to interface the control lines and data lines to the LCD. These ten K's serial resistors are not essential and you may omit them for simplicity. The ground pin on the LCD should be connected to VSSD digital ground on the Cypress dev kit. VCC should be connected to five volts. Remember we're using the nscope to supply five volts in the system. The VL pin controls the contrast of the LCD and here's where we need two more resistors ten k and one hundred ohm are the values used here but you could substitute similar values as long as the voltage at that point is about the same. Point one micro ferric capacitor should also be connected between the LCD power pin and the VSSD digital ground on the Cypress dev kit and that's it. That's all you have to do to physically hook up the LCD to our system. Now that we have the LCD physically wired up we need some code to make it work. This is a good example of where reading the manual might leave you a little bit more confused than enlightened. That's because the manual has to cover all the features of the LCD. But in practice you only need to know about ten percent of that to make it work usefully. So to cut to the chase I'm just going to show you a quick code snippet and show you a few important things you need to know about the LCD to make it work correctly. Let's start with line twenty five that all important start function. I've said it before but it bears repeating. If you forget to start a component it won't do anything. The exception to the rule are pins. Pins don't require a start function but pretty much everything else does. After starting the next thing we have to do is set where the cursor is on the LCD. There are two arguments. The first argument is the row number and the second argument is a column number and notice it begins counting at zero. If you forget to do this it's going to write in the wrong place. To write a string, just some characters to the LCD you just use the LCD print string instruction. And here I have written. University of Colorado. Here's how the manual explains the print string instruction. Notice that nowhere does it say you can simply enclose the text you want to print in double quotation marks. This is a good example of how reading the manual doesn't always get you where you need to go. Down on line forty one, we re-positioned the LCD cursor so now that it's on the second line and second row which remember it starts from zero so it's one one and we print another string and this case the strings completely blank line forty two. The reason I do that is because the LCD will not write to a position on the display unless you specifically tell it to and it's very easy to leave orphaned characters on the display. Something that's happened to me many times. After making sure that second line is blank. I positioned the display to the six character in the display and then I printed unsigned thirty two bit number called loop counter, that I defined previously. After that I delay two hundred and fifty milliseconds using a can Cypress function called CY delay. That's very important to do because it is quite possible with the LCD to write to it faster than it can really respond that if you do that you'll see your LCD fading out. And since humans generally cannot read faster than about three four times a second there's no point writing to the LCD any faster than that. So that's really all you need to know in order to use the LCD. I showed you how to wire it up and then I showed you the simple code to write characters and write numbers to the LCD. You can do a lot more with it than that but this is all you need to do basic debugging. Remember that the LCD is just one of several tools used to debug in an embedded system. It's useful when you need to look at the value of relatively slowly changing variables in real time. Unlike the debugger you don't have to stop the code. The code is executing and writing to the LCD on the fly at some sample rate. A good example of this is reading temperatures since that doesn't change too rapidly. But let's say you are looking at the current in a brushless DC motor as it moves of robot rapidly. The motor speed and the current is changing much too rapidly for you to see what's going on by riding it to an LCD. In that case you'd be better off using a DAC hooked to an oscilloscope. Using the right debug tool for the problem at hand requires a little bit of experience. You'll gain that as we continue to explore embedding sensors and actuators.

5: How UART's Work


Interactive Transcript - Enable basic transcript mode by pressing the escape key
You may navigate through the transcript using tab. To save a note for a section of text press ⌘ + S. To expand your selection you may use ⌘ + arrow key. You may contract your selection using shift + ⌘ + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using ⌘ in conjunction with the alt key

For those of you unfamiliar with serial communication, I'll start with the basics. The rest of you may skip ahead. This lecture will cover some important aspects of serial communication, and specifically using the PSoC UART, but will not get into every detail. Emphasis will be placed on what you need to know and certain points that are either not well covered or well emphasized by other information sources. And there are, of course, a lot of other information sources out there. For full details, read the UART data sheet available within the PSoC creator software.

There are many ways to connect a microcontroller to another device, such as a sensor or a display. The simplest method is a direct parallel connection, where we connect each bit of some memory location in the microcontroller, usually called an I/O port, to a matching location on the other device. This results in a fast, reliable connection. But in a 32-bit device, it requires 32 I/O pins and wires. And anyone who has looked closely at a modern circuit board realizes that both are precious commodity. This is where serial communication comes in. Instead of moving 32 bits at once, we instead move one bit at a time using a shift register. This is, of course, much slower than a parallel interface, but it turns out that many forms of data transfer do not require super high speeds. A lot of data sources will talk about serial communication being done with a single wire, but you always have to have a ground connection between the two sources unless you're doing wireless transmission. So the minimum is really two wires.

There are many serial communication standards in use today. Some of the most common ones are I2C, SPI, ethernet, bluetooth, which is wireless, of course, and RS-232. They differ in their exact implementation, but all use a shift register. Some of these are much faster than others. Some of them allow communication between a single point and many receivers, and others allow two-way communication between many receivers. It all depends on which standard we're talking about.

A UART is a device designed to implement the ancient RS-232 serial data communication standard. It dates back to 1960. Not too many things in the computer field are still in use that date back to 1960. It has proved so useful that it's in common use today. Some things never change.

The primary advantage of RS-232 is it just requires two wires in its simplest form, ground and one signal wire. This immediately presents an interesting problem. If data is shifted out on the signal wire one bit at a time, how does the receiving device know when each data bit is present? It will see only a series of high and low voltages.

You might imagine that we could add another line that would go high when the data is stable and ready to be sampled. Typically, this is done in other communication standards, and it's called a clock line, and that is what synchronous data communication is. There's a clock that tells the receiver when the data is present, but a UART doesn't have that. It saves out extra wire, so it really can operate with just two wires. But you have to somehow figure out when the data is stable and ready to be sampled when you're receiving it.

Both the I2C and SPI, and other types of serial data communication standards use a separate line, a clock line, that tells the receiving device when to sample the data. This is more accurate than the way the UART does it, because over time, the further and further you get from that leading edge that everything is based off of, the greater the chance is that you'll have a mismatch in where you sample the data. If you have a clock line, you don't have that problem because the clock line is constantly telling you when the next bit is occurring, usually on the rising edge of the clock. The solution lies in timing each bit from the first falling edge of data transmission. The signal wire will sit high, and when it goes low, you start to do timing. In order to do this, of course, the receiving device will have to know in advance not only the pattern of the data, but also the rate of the data transmission. It has to know how long to time until the first bit and the subsequent bits. Mismatches in the agreed rate will result in garbled data, and you might have seen this when you're trying to set up a serial communication link with your PC. You'll always see a place to define the data rate when setting up a UART.

Here's what that looks like in a PSoC configuration window.

In this case, notice that the data rate is set to 57600 bits per second. We'll talk about the other fields in a minute. Besides requiring an extra wire, there's another reason not to use a clock line, and that is interference between adjacent wires. Clock lines are generally very rapidly changing high frequency signals, and that's the sort of signal that couples very well in between adjacent traces. If you look closely, you can often see a little bit of clock noise on signal lines if they're close together, the UART doesn't have that problem.

Once a UART has been placed on a PSoC schematic and properly configured, data transmission can take place simply by writing a single byte of data to it. The UART takes care of assembling the data in the right format and moving it out one byte at a time, thereby relieving the CPU from any further action. It's a hardware assist. Here's what that code looks like. It's just a single PutChar command. There are other commands in the PSoC data library which will put more than a single byte into the UART. For instance, there's a put string command that will allow you to put an entire series of ASCII characters into the UART. This doesn't mean that the UART is any faster and ultimately, underneath the hood, the data is going into the UART one byte at a time.

The UART does more than simply shift data out one bit at a time. It also formats the data. And by this, I mean the UART is responsible for automatically adding some extra bits to the serial data string. These are the parity and stop bits. Use of a parity bit is optional. It aids in error checking. If used, it is appended to the transmitted byte, and now we're up to nine bits total.

Use of the parity bit must be agreed upon in advance between the receiver and the transmitter. If the settings do not match, communication will not work. The polarity of the parity bit is chosen to make the total number of ones, including the parity bit, equal to either an odd or an even number. And yet, that's another setting that you have to agree on. There's something called odd parity and even parity. So first of all, you have to agree to use parity in the first place. And secondly, you have to decide whether it's odd or even. And it will be calculated on the sum of all eight data bits plus the parity bit. Here we have chosen to use even parity in the PSoC UART configuration dialog.

Remember, the receiving UART is responsible for recalculating parity on the nine bits received and declaring an error if the calculation is not even or odd, as was agreed to in advance. Of course, if two bits have flipped, the parity check will succeed anyway, and the error will go undetected. This is a limitation of this simple error checking scheme. More advanced communication formats use more bits to define checksums which can detect, and in some cases, even correct multiple bits in error.

The UART is also responsible for adding one or more so called stop bits to the serial data streams. These are added after the parity bit. Unlike parity, the standard requires at least one stop bit. There can be two, but no more.

Once again, if the number of stop bits sent by the transmitter does not match the number expected by the receiver, data errors can result.

Here is an example of a serial communication program called PuTTY, running on a Windows 10 PC. Notice the similarities to the UART configuration and PSoC creator. Similar, but not the same. Other serial communication programs will have similar setup dialogues. In some cases, the receiver will not be a PC, but the settings will still have to be defined somehow. If you haven't defined those settings, things aren't going to work.

Serial communication is complicated by the speed mismatch between how fast the CPU can write a single byte to the UART using a PutChar command, for instance, versus how long it takes the UART to actually move that data out to a receiver. In general, the CPU is much, much faster than the UART, so care must be taken to make sure the UART is ready for new data before writing to it. If you make this mistake, you will clobber the old data. This is known as an overrun error.

Calculating the exact time per instruction in any microprocessor can be surprisingly complex, but it is easy to measure. Here, I created a simple program to do so, using the oscilloscope, but connected to a test point. With a CY8CKIT-059, that's the little board that plugs directly into a USB port. Configured with a bus clock speed of 24 MHz, which is usually what it is. The scope shows a positive going pulse of around 1.9 microseconds. This is how long the CPU takes to put a single byte in the UART. If the UART is configured for 9600 bod, a common setting, it will need 1042 microseconds to shift out a 10-bit frame consisting of a start bit, the eight data bits and one stop bit. That's over 500 times slower the rate that the CPU could stuff data into it. So precautions must be taken not to do that. Even at the fastest data rate available in the PSoC UART configuration, the time needed by the UART to flush a single byte is 11 microseconds, and that's still much slower than the CPU can put data into the UART. PSoC creator includes a function that allows the CPU to check if the UART is ready. For instance, the Read Transmit Status command checks to see if the last byte written to the UART has been sent already. However, in many cases, we do not want to slow the fast CPU by making it wait for the slow UART. This is where the transmit buffer comes in.

The PSoC UART can be configured to include a transmit buffer. This is not part of the old RS-232 standard and therefore technically not what a UART does, but it is a very common and useful feature. A buffer is simply a piece of memory that the CPU can write to at full speed. In the PSoC 5LP chip, the buffer hardware is only four bytes deep, although the configuration menu allows you to create a much deeper buffer using system RAM that emulates it. Of course, this requires software to do so and slows things down, but the details are taken care of by the automatically generated code.

The PSoC UART automatically moves data through the buffer in a first in, first out fashion and transmits it without further CPU intervention. Again, it's a hardware assist. The CPU can go off and do something else while the UART takes care of these details.

This allows the CPU to write a number of bytes at full CPU speed without waiting for each byte to be transmitted by the much slower UART. Of course, this convenience comes with some caveats. The CPU must be careful not to overfill the buffer. PSoC creator includes a special function call specifically for this purpose. You can read the size of the transmit buffer.

But this isn't the only bottleneck in the system. Besides making sure the CPU doesn't overrun the UART, the transmitting UART must be careful not to overrun the receiving UART. This is where you'll hear the term flow control. In this case, the problem is not as extreme as the CPU to UART interface, since both UARTs must be configured to run at the same speed. Even if this is done, however, the CPU connected to the UART at the receive again might not be reading the data out of the UART as fast as it's coming in.

The PSoC configuration menu allows for status lines to be added to the UART to signal when the data can be sent. This is what happens when you configure the UART for, quote, hardware flow control, unquote. You'll see a few pins added to the UART. Details are well covered in the UART data sheet, and it works pretty much the way you think it might. Quoting directly from the data sheet, quote, the CTS line is an input to the UART that is set by the other UART in the system when it is okay to send data on the bus. The RTS line is an output of the UART informing the other UART on the bus that is ready to receive data, unquote. So these two lines are responsible for avoiding buffer overflow between the two UARTs. That's entirely different than buffer overflow coming from the CPU going to one of the UARTs. The UART may be configured for so called full duplex operation. Here it's called full UART, but the usual term is full duplex, and that means it can transmit and receive at the same time. So there are shift registers which are duplicated such that each UART has both a transmit and receive line. Another option is so called half duplex operation. In this case, you still have a transmit and receive line, but they cannot be used at the same time.

So what's going on when you use a UART on the PSoC development board and somehow it connects through a USB connector and ends up on a window running on your laptop? Well, there's a lot going on under the hood. The development board actually contains a second PSoC microprocessor that generally you don't write any code for. It's all hardwired, but that microprocessor takes the UART signal from your microprocessor, the one that you actually program, and translates that data into a USB compatible package. And that's how it ends up talking to your PC.

Once again, remember that your PC will have to have a terminal emulation program. Some of the more popular ones are PuTTY and HyperTerminal. Once you run that program, you'll have to make sure that the serial port connections match exactly what the UART is doing on your PSoC board. One setting you need to pay particular attention to is the comport setting, because that can change every time you connect a PSoC development kit to your computer. The operating system decides at that time what number will be assigned to the comport. You have to look at the control panel in Windows to determine what choice it made, and then enter a matching comport number in the serial communication program you are using, such as PuTTY. Here, we selected COM1, but it could easily have been something else, and it might change the next time you disconnect and reconnect your development kit.

So far, this lecture has covered most of what you need to know to use the PSoC UART, but time prevents me from going into every detail.

Note that the UART data sheet is 56 pages long, so there are a lot of details. I have tried to emphasize a number of points that I think that are not well covered elsewhere, and I hope this has been useful to you.

6: Debugging with GPIO and DACs

In any embedded project involving both hardware and software, eventually you're going to have to face the problem of debugging it. PSoC offers several unique opportunities for debugging that you won't find with many other chips. Some of them are standard though. Starting with the debugger. Here in the upper left-hand corner, we have two options for loading the code. We have the standard option, which just loads the code and the code will immediately begin to run, or we have the debug option. These are mutually exclusive. If you choose the debug option to load your code, you will get certain features that are not found with the other options. These include the ability to start and stop the code at will, and when the code is stopped, you will be able to look at the values of variables in the code and be able to change the value of variables in the code. The controls for the debug option appear on the top of your screen, possibly in a different position than this because these buttons can be moved around at will and stacked on top of one another if you want. The green triangles starts the code. The two slashes will pause the code execution. And you could just restart it immediately using the green triangle. The blue square stops debugging and will exit the debug mode. If you hit that, you're going to have to reload the code which takes a few seconds. So, most of the time, you'll just use this pause button. This is all pretty standard stuff. IDEs or Integrated Development Environments have been doing this sort of debug for many years. If you need to learn more about how the debugger works, check out the training videos on the Cypress website. I won't repeat those here. Another common debug technique that is very useful for real time applications is the use of GPIO pins to put out pulses when certain things happen in the code. On this design, I'm using P0_0. I use P0_0 to mark how long it takes to execute the infinite loop in this particular piece of code. Over here on line 66, I simply write a one to P0_0 when the loop begins and then somewhere else in the function. Right there on line 112, I write it to zero. What I get from this is simply a square wave and it tells me two things. The period of the square wave tells me how long it took me to go through that loop and the time that the square wave is high tells me how long it took me to go from the beginning of the loop to line 112. So, this is very analogous to just simply blinking an LED, which is usually the first thing one tries to do with any new Integrated Development Environment. It's a little bit more information than that because if you hook that GPIO pin up on a scope, you get timing information. Looking at a scope trace of P0_0, we see that the time through the infinite loop takes about 53 microseconds. But most of that is taken up going from the beginning at line 66 to line 112. A useful extension of this idea is to write a different pulse width for every event you want to mark in your code. So, in this case, I've used a commonly used canned function from the CY boot routine called CyDelay to create a one microsecond delay. Later in the code, I use the same function to create a two microsecond delay. By now, some of you have realized you can even write a variable delay and have pulse-width indicate the value of a variable in the code. For instance, in this example, I have some variable I call sample and I'm using that to create a variable delay in the code. One must be careful though, because the value of the variable you want to display may be a pretty large number and you'll create a rather large delay. You can always scale this by dividing by some appropriate factor of course. Here, I just divided by eight but you could play even more sophisticated games. For instance, you could put a hard limit on the values, so that you can have fine resolution when the value is small, but not accidentally create a very long delay. There's another neat debug trick you can use with PSoC and that's the use of DACs or digital analog converters. These produce a variable output voltage amplitude, not pulse-width this time but the amplitude is variable and you can easily use them simply by writing an 8-bit unsigned number to the DAC itself. Let's see how that works. This little piece of code is added to the beginning of the infinite loop. I write a large value to the DAC for just 2 microseconds. That creates a nice spike that's easy for the oscilloscope to trigger on. I use the same DAC in the same IO pin to mark the beginning of an ADC conversion cycle and when this conversion cycle completes, I change the value to the DAC so that I know how long it took. Notice, I didn't have to add any more GPIO pins or any more DACs. I'm using the same part to get more information out of the code. Here's what it looks like on oscilloscope. The large pulse is located at time T0 and it's very easy for the oscilloscope to be triggered on. Then we notice that the DACs stays at about a half a volt for 10 microseconds. Well, that's the conversion time of the ADC. After that, it jumps up to about one and a half volts, it stays there until 20 microseconds. That's just how long it takes to execute the remainder of the loop until we get back to the beginning and write that big pulse again. But wait, there's more. Take a look at this code snippet. I use it to control how often I write to the LCD. I could use a function called is LCD ready, or I could just do it the simple way where I increment a counter called LCD count every time I go through the loop and when the counter reaches some limit called LCD count limit, then I write to the LCD. I reset the LCD count, and we can go through the loop many times before writing to it again. Normally, I have that value set at 10,000 because my loop runs pretty fast that I only need to write to the LCD every 10,000 times through the loop. If I write to it too fast, it will start to fade out. However, for illustrative purposes, I'm going to change the LCD count limit to a much smaller number, five for instance. What effect will this have on the scope trace. Well, every time we go through the loop and we don't write to the LCD, we expect the loop time to be shorter than those times that we go through the loop and do write to the LCD. And we can see that very quickly on the scope. Let's take a look. Notice, that I still have the trigger set at time zero and most of the time, the loop takes about 10 microseconds. But every now and then, it takes longer. It jumps to about, looks like about 11 and a half microseconds, which tells me several things. One is, we have some idea about how often the loop is taking longer, just by watching for a few seconds. And we also know how long it takes to write to the LCD. Even more insight can be gained by using some of the different display modes available in modern oscilloscope. For instance, let's take a look at Infinite Persistence Mode. At a glance, we can see that the loop time takes one of two values. There are no intermediate values. If there were, we would see an additional spike on this display. This particular a oscilloscope uses color coding, which tells us something about how often each pixel was displayed, although the exact timing is not clear. Some of oscilloscope have averaging mode display. Unfortunately, the endoscope does not but some more expensive oscilloscopes will have that. Think of what would happen if you put this type of signal into an averaging mode. The more often a pulse occurs at a particular location, the higher its amplitude would be, and the less often it occurred at a particular location, the lower its amplitude would be. In other words, in averaging mode, the amplitude of the pulses will tell you how often the pulse occurs at that location. Of course, in our example we know how often the code writes to the LCD and so we have a good idea of what those two amplitudes would be. In other cases, this is not the case and using averaging mode with a DAC output or even a GPIO pin output can tell you how often things happen in the code. Hopefully, most of your debug problems will be easily solved using simple start, stop, and break point techniques in the debugger. That's not always going to be the case however, and so I hope this video has given you some idea of how to use GPIO pins and DAC outputs and different scope display modes to obtain a more sophisticated insight as to the behavior of your embedded design.

7: Documenting Components not in the PSoC Chip

The PSoC chip is very flexible and contains a wide variety of components internal to the IC that you can connect in a wide variety of configurations. But sometimes, it's necessary to use parts that you cannot integrate into an IC. For instance, power components or inductors. These are going to have to be added externally to that white breadboard that comes with the development environment. Sometimes, you'll get lucky and you'll be able to plug the external component directly into the white breadboard. 14-pin dual inline packages are an example. Other times, usually inductors or anything larger, you're going to have to solder wires to the external components and use the wires to connect to the breadboard. So, how do we keep track of these external components on the schematic? Well, we use the off chip tab in the component catalog. This provides symbols for external components which are not part of the PSoC chip but are part of the schematic. You use these just like the internal components. Just select one from a component catalog and place it on the schematic. For instance here, we'll use an LED. You'll notice, that the part appears in blue and that is a way to distinguish that it is not actually inside the chip, but it's on that breadboard. Here, I'll select a external 10K resistor and put that on the schematic and hook it up to the LED. Notice, that the manipulation is exactly the same as the internal components on the PSoC schematic. PSoC creator has a special technique to indicate a connection between an external component and an internal component like this pin labeled LED_P0_3. We can figure that pin and select External terminal which puts a blue connection point on the pin that allows you to connect to two external components. And here, I'll do that by just lining up the little box on the 10K resistor with the little blue box on LED_P0_3 and that's how you make that connection. Of course, we're not quite done here, that diode needs to connect to ground and use Vss for that purpose. You might be confused about the various terms used for ground. Sometimes, it's called Vss, sometimes it's called Vssa, and sometimes it's called Vssd. For external components, it's just called Vss, but you can change that in the configuration. The difference between analog and digital ground is important and will be covered in later lectures. The default resistors symbol is 10K, and some of you realize that, that's not going to light the LED too brightly and we can change that value on an external component just the same way that you change it on an internal component. This consistency is one of the reasons why I like this integrated development environment. So one of you, probably, won't like the dash lines. You can change this under Tools, Options, Design Entry, General and scroll all the way down to External Wire Style. Change that from a dash, click there, to a solid. I like the looks of that, a lot better myself. By the way, this IDE is highly configurable. If you go to Tools, Options, you'll be able to do a lot more than simply change the style of external component wires. You can change all sorts of aspects of the way the system behaves. I've left most of these in the default condition because I don't want to have to explain what changes I've made. But I encourage you to go through this list here and take a look at the different things that you can do. One of the few changes that I often make is, to change the default radix of numbers that are displayed when using the debugger. If you go here to Program, Debug, and General, you'll see that the Default Radix is currently hexadecimal, and depending on what I'm doing I usually like to change it to decimal display. That only applies when you are using the debugger and you're looking at the value of variables. One other interesting thing to note here is, how the code behaves after you load with debugger options? It's not quite obvious here, but on the line where it says, On Run/Reset, Run to, the radio button for Main is checked. The behavior, in that case, is that the code, after being loaded with debugger options, will be paused on the first line of main dot C, and it won't start running until you hit the green triangle button in the debugger. We should also know that the arrangements of the buttons on the screen is highly flexible. They're arranged into groups and in each group, there's a dotted line on the left side. If you mouse over that, and left click and hold it, you can move the buttons around. So, the arrangement of the buttons you see on my screen might look very different, than the arrangements you see on your screen. You can also add and remove buttons. Just go into the gray area to the left of the button menu, right click, and select Customize. You'll see all sorts of options to change the way that the toolbars appear. I encourage you to experiment with that, but I'm not going to explain all the details now. Here, are just a few of the Off Chip components symbols which are available. We have motors, inductors, potentiometers, fuses, and so on. Things you could never integrate into an IC. So, that's it for this lesson in how to use external or Off Chip components to document your design. I encourage good documentation because it frees your thinking up for the more difficult problems that you'll encounter when embedding sensors and actuators.

8: Pin Types

Today, we're going to talk about the use of pins in PSoC. If you look on the component catalogue here on the right side, and expand the ports and pins line, you'll see there are four different types of pins. It's important to note that in PSoC, pins are actually entire circuits that are very configurable. Let's demonstrate this by putting a digital output pin on the schematic. I'll just left click drag one over to the schematic and set it there. Notice that the name as a default is Pin_1. It's important to note that this is just a name and does not imply that the pin is actually connected to pin 1 on the chip. It's a little confusing, so I'd like to immediately reconfigure the pin and change this name to match the port and pin number that I intend to use. I can do that by mousing over the component right clicking go to configure. You should have seen this before. And here, I get the configuration menu for a pin and see how complicated it is. It's a lot more than simply a single pen. But the first thing I'd be concerned with is that name in the upper left hand corner which defaulted to Pin_1. And I'm planning on using this pen with port 0 bit 0 or else I'll name it P zero underscore zero. We're very limited on the range of characters that you can use in pin names. For instance you cannot use special characters like dashes or parentheses, so to indicate port 0 bit 0, I'll just say P zero underscore zero. So what are all these other options? Well, notice there are three tabs here in the middle. General, input, and output. Let's start with that general tab. Notice that digital output is checked, and hardware connection is checked. You could if want to uncheck these and check digital input, and you've just done the same thing as if you had selected digital input from the component catalog. But let's leave it as a digital output, and I wouldn't have it be both at the same time because that's kind of an advanced topic. The hardware connection means that you can connect it on the schematic to other components if you had unchecked this. The only thing you could do with that digital output is write to it using an API specific to P zero underscore zero. And that API would be generated when you build the code. For instance with this hardware connection, I might have the output of a competitor for instance that I might want to drive this output pin with. And I would need that HW connection there to do that. If I uncheck this box and hit OK. It's actually not necessary to hit apply first. Notice that it looks a little bit different. There's no connection box here anymore. I go back and reconfigure that and reset the hardware connection, hit OK. There's that connection box and I can use that green wire to connect to other digital components. By changing the name from the default pin 1 to P zero underscore zero, is only a name change. It does not actually make the connection. In PSoC, in order to make that connection, you have to go over here to this Pins line item in Workspace Explorer, and double click on that. And if you do, you'll get the pin assignment window here that shows the name that we just assigned. There it is P zero underscore zero. I'll ignore the pin column, and instead look at the port column over here. Pull down that window and notice it list many of the pins on PSoC. Not all of them, but many of them. And there is port 0 bit 0. Next to it it says OpAmp vout, and that's just letting you know that if you are using an OpAmp, that OpAmp has a direct connection to port 0 bit 0. But we're not using an OpAMp, we're just using it as a general purpose digital outputs. So double click that, and notice under the port column I see P zero square bracket zero square bracket and that matches a name P zero underscore zero. It even tells us which pin is assigned. Assuming that you have selected the right chip in the family of PSoC parts, which in our development board it's a CY8C5888LTI-LP097. Even shows you a picture of that chip. And sure enough, up there on the upper right you'll see port 0 bit 0 is pin 48 and it's named P0_0. So it's very important to do this step where you use the pins tab and you match the name you created to the physical port and pin number in the pin assignments page. If you forget to do that, it might look like it's P zero underscore zero on the schematic, but it could be connected to anything else. As a matter of fact if you fail to do this step, PSoC will assign some random location to it and it won't take into account what your name was. Let's go back and look at some of those other options under the pin configuration. I'll right click here. Go down to configure left click, and let's take a look at some of the other options here. Notice under the general tab, we could change it to an analog pin. We could change it to a digital input pin, or I could just leave it as a digital output pin. We've already covered what the hardware connection is, that's for connections on the schematic. If you uncheck that, you can only write to it from software. Another interesting option is the external terminal option, and that's for connecting to external compote is known as it adds another connection point here and the wire color is blue. That is done to indicate that the component that is being connected to here is not inside the PSoC chip, but it's something that you've added to your board. We'll cover more of that later. For now, let's not make that selection all on check external terminal. What does the input do? Well, this is a digital output pin here, so there aren't any options for input. Notice it's grayed out. There are however options for output since I selected here under the general tab that it's a digital output pin so the output tab is not grayed out. You can change all sorts of things here, but they do tell you interestingly that the current level that it can drive is just four milliamps sourcing, which means out of the chip, or eight milliamp sinking which means into the chip. Some of these other modes are advanced topics that we won't talk about right here. Let's go back to that general tab, and then look at the drive mode because this is important. When it's selected for the default which has strong drive, that means there's a transistor above the pin and below the pin. And these transistors can be turned on alternately although not at the same time. And that will pull the pin up to VDDIO, which is usually five volts in our system, or this transistor, this lower transistor will turn on and that will pull the pin down towards ground often referred to as VSS in this schematic. Most of the time that's all you'll need. You'll just need the strong drive mode. If you're interested, notice that there is one, two, three, four, five, six, seven, eight other types of drive mode. The most interesting ones being resistive pull up and resistive pull down. We select resistive pull up. Notice that it inserts a resistor, doesn't tell you what the value of the resistor is, and inserts a resistor between the pin and VDDIO shown at the VIO here, but you just call it five volts. Resistive pull up is very useful for some applications. Some chips like i2c bus is require it. Right now, we won't use that. So that's quite a few options for something as simple as a pin, and we're really not going to show you everything that's in the configuration. The important thing to know is that there's three basic types, and that's analog, digital input, and digital output. These can be changed with the configuration window, or you can select them directly off the menu here. And notice this all look a little bit different. Notice that the digital pins have a green wire attached to them, and the hardware connection for an input is on the left, hardware connection being this little square box. The hardware connection for digital output pin is on the right being this little square box. And notice something interesting here. I named the analog pin at the top P zero underscore zero. Then I went to the pins tab, clicked on that and used a pull down menu to assign it to port 0 bit 0, and that now shows up in this little box which is a nice way to confirm that the pins are physically connected to match the names that you gave them previously. So that's the basics of using pins in PSoC, at least is needed for this course. We'll cover any other features as necessary in future lesson.

9: Digital to Analog and Back Again


Let's talk a bit about this idea of mixed signal systems. By that, I mean any system which combines analog and digital circuitry. PSoC does this inside one chip. They're analog components like op-amps, programmable gain amplifiers or PGAs, analog Balta plexus, and other things. But there are also digital components like counters, PWN generators, and logic blocks. The signals for the analog components are easily corrupted by the fast rise time of the digital signals and for this reason, they are routed separately inside the chip. You can see this sounds schematic because PSoC created uses different colors for each. The default color scheme is that green traces are used for digital signals and orange is used for analogue. It's important to note that the current vision of PSoC Creator 4.0 Update 1 will not complain if you connect an analog signal to a digital one until the project is built. For instance, I can put an analog pin on the board and I can put a digital pin on the board and if I just try to connect them with a wire tool over here, it'll do it but we won't see any errors. So, if you can't connect analog to digital signals, how are they related inside the chip? There are several components in the schematic to bridge this gap each in a different direction. Analog to digital converters have, as their name implies, analog inputs and digital outputs. However, the digital outputs in this case cannot be directly connected to other components on the schematic using wires. Instead, the usual procedure is just to read the output of the ADC using software. Here, I put an analog to digital converter that the delta sigma type on the board, I connected both inputs to two analog pins, port 0 bit 0 port 0 bit 1 and I built the project. After the projects is built on the left side in the workspace explorer section, you will see a whole bunch of functions related to it but will concentrate on the first one which is ADC_DelSig.c I click on that. It'll come up over here. And one of the functions you need will be this one. ADC_DelSig_1 and that's exactly the name that appeared on the schematic, GetResult32. That's if you use a ADC as an 8 or 16 or even a 20 bit ADC converter, you can put it into a 32 bit number using this function. I should caution you that ADC is a little bit more complicated to use than just simply reading the value. They have to be first started which really means powered up using a start function which is also available in this file here somewhere. There it is. It looks like this. Again, that's exactly the name off the schematic ADC DelSig_1 and then it says Start. You have to call this function once before you use the ADC or it will remain powered off and not give you any results at all. In addition, after powering it up using a function called Start, there's another function called Start convert which actually begins the process of analog to digital conversion. Furthermore, analog to digital conversions can take longer than a single line of code takes to execute. Therefore, you have to check to see when the conversion is done before you can read the ADC and of course there's another function to do that. That function is called IsEndConversion and it has a few different ways you can use it. You have to read the documentation to find out all the details. But using an ADD converter usually requires at least four lines of code to get it running. The PSoC 5LP dev kit actually contains three ADCs. One, high precision delta sigma type shown here. But two, lower resolution much faster successive approximation ADCs. Those devices can go to a million samples per second. Each of these parts has a number of set-up options governing things like sample rate resolution and other factors. We'll dig into that another time. The other component used to bridge the analog to digital gap is of course the aptly named digital to analog converter. The PSoC 5LP chip has four of these available and you can find them under analog DAC. There's four different types but let's just be concerned with the voltage DAC here, it's the simplest type. I'll put one of those on the board. Depending on how you set up this component using the configuration menu, it will output either between zero and 1.02 volts or between zero and 4.08 volts depending on what number you write to the DAC and the DAC is an 8 bit DAC which is not all that high resolution as these things go. There are options to change the speed which we usually don't do and the type of input. The input can be a number written to it from the CPU or can actually come from a bus pin. And if I can figure that DAC to get its data from an 8 bit bus, it looks different now. It shows data seven through zero and a clock or strobe pin here and we still have that analog output. Connecting wires between buses which are more than one bit and single wires requires a little bit of knowledge of exactly how PSoC does its nomenclature. In this picture I just use the wire tool to extend the green wire from the data seven through zero line and notice it is a thick line. If I go over to the wire tool now and just arbitrarily put a wire somewhere else on the board, notice it is a much thinner wire. Both of these wires have names and if the names match, they can be connected together easily. To see the name you just move over to the wire, you right click and you go to Edit Name and Width. And for our purposes, it's easier if we just uncheck this box and give it a particular name and we'll say, DAC_bus for instance. Notice it's a bus. It has seven through zero wires in it. Hit okay, and the name appears on the schematic although unfortunately it lined up on top of this component symbol. I'll just pull it off so you can see it. That's the name of that bus. I can do the same for this single piece of wire over here. Right click Edit Name and Width, uncheck that box and give it exactly the same name DAC_bus. But now, I'll say it's a single bit and I can make it any bit in the bus I want. For instance, I can make it bit five. I say okay. And now you've told creator, you made a connection between this bus name and that single wire and you are now allowed to connect these. And if I do so, it looks like that. We have a thin wire connected to a fat wire, the fat wire indicates that it's actually a group and that has wired up one wire to the eight that we need for this DAC input. DACs are extremely useful components for a number of applications but you shouldn't assume they are highly precise devices. While everyone wants to know accuracy, what you'll find in the data sheet defines many different terms that add in unclear ways to get a true accuracy. For instance, there is a specification for both differential and integral nonlinearity. Specifications like these are common for both DACs and ADCs, but the thing to remember is that they are imperfect. Very accurate results may be obtained with PSoC but you have to know what you are doing. We'll talk more about that in a later video. And let's not forget the comparative component. If we go over to the cypress tab here and look under comparators, we'll pick the first one off a list comparator v 2.0 and put it on here. The comparator has two analog inputs and one digital output. And of course if the analog input present at the plus symbol is greater than the analog input present at the minus symbol at the time, we have a rising edge here for the clock then the output will go high. Otherwise, it will go low after some significant amount of delay time. The strobe option or the clock here is actually a configurable option. If I click on bypass, you'll notice it doesn't say strobe, it says sync. I click on bypass then it doesn't appear. That's actually a very useful tool in some designs. One final note. PSoC has very flexible routing but there are preferred pins for analog and digital signals. This is done to reduce noise pickup and it's a good idea to use ports 0 and 3 for analog signals. If you're really curious, the entire routing fabric can be viewed by clicking on the analog line in workspace explorer. This will show you which internal switching transistors are used in your

10: A Basic Sensor Interface in PSoC

Sensor interfaces can take many forms. But there are a few common issues to all of them. The first is what we call excitation, that is applying power to a sensor. While that may sound trivial, it isn't. Connecting a sensor to whatever power supply is available can introduce noise that corrupts the signal that you were trying to read. It may be necessary in some cases to filter the power supply noise before using it to power a sensor.

Some sensors, thermocouples come to mind, do not require any external power as they create their own voltages. Usually such voltages are too small to be directly applied to the input of an ADC, and thus require some amount of amplification.

Like all micro controllers, PSoC runs off a single-ended power supply, which means it can only interface to voltages between ground and VDD, which is usually 5 volts for our purposes. Of course, not all sensors are limited to this range and when this occurs you'll have to use external components to clamp the applied voltages to the range that PSoC can handle.

So how do we do this? Well, take a look at this schematic here. In this case, I've assume that we have some external voltage that might sometimes be greater than 5 volts, or in fact might be less than ground. And we want to apply that voltage to port 3, bit 2, which is an analog pin. And I've drawn a couple of Schottky diodes here, that will clamp this voltage, basically provide a low impedance path to 5 volts or from ground to limit the voltage at port 3, bit 2.

That's a common technique, but it may get you into trouble here.

Like any other component, the pins component has a data sheet.

It's really a circuit, it's not just a pin, it's really a circuit. And in the data sheet, you will find electrical characteristics for those pins. These are important to look at.

It's important to note that inside the PSoC chip, there are already Schottky protection diodes, and if you put Schottky protection diodes on the outside of the chip, well now, you have two diodes in parallel. When you have two diodes of the same type in parallel, it's not clear how the current will be shared. Most of the current could go through the external diode, or it could go through the internal diode. It depends on exactly how the diodes were created. And if we are unlucky enough that most of the current goes through the internal diode, then the external diode is not helping us at all. The internal diodes are limited to about 100 microamps and that's right here in the data sheet. If you scroll down you'll see a specification for I diode which is the current through the protection diode to VDD or Vss, and that's only 100 microamps. So if your external current source goes to 6, 7 or God forbid 200 volts, the current will flow through both of the diodes, the external one and the internal one. And you can quickly burn out the internal one because 100 microamps is not a lot of current. So what to do about this? What you do is you're going to have to add a current limiting resistor to the circuit external to the PSoC. Here's an improved circuit. This one will be safe even if that external voltage exceeds 5 volts.

I've added a 10K current-limiting resistor between the external Schottky diodes and the PSoC pin which has it's own internal Schottky diodes.

With this design, if Vdd is 5 volts and the Schottky diode forward voltage is less than about half a volt,

then the voltage at this point can never be greater than 5.5 or less than minus 0.5 if this guy goes below ground.

That means the current in this path, which needs to be limited limited to 100 microamps max, only requires a 5K resistor, but I put a 10K resistor in there just to provide some margin. So this is a safe way to protect this analog input from an external sensor, or whatever, something you want to sense that could exceed the voltage applied to the power pin of PsoC Vdd or if it can go below ground. This is the way to do it.

There is, however, a price to be paid for this protection.

Remember that all GPIO pins, and pretty much anything for that matter, exhibit a certain amount of capacitance. This can be as much as 20 picoFarads for some pins, again according to the PSoC 5LP family data sheet.

Here's what that document looks like. Of course, you can find that on the Cypress website.

And if we scroll down,you'll find this line, input capacitance, and it varies by pins. But it's on the order of single digit to tens of picoFarads. That's not really a lot. Your typical oscilloscope probe has about that much. But it makes a difference when it comes to high frequency operation, because the input capacitance of the PSoC chip, in combination with that series resistor of 10K, forms a RC low-pass filter. And that limits how fast a signal you can apply externally and still see it in PSoC.

If you are dealing with frequencies in the audio frequency range, let's say 10 to 20 kilohertz, this is usually not a big deal. But if you get up into the hundreds of kilohertz or megahertz, then it starts to make a difference, and you can lose amplitude at the PSoC input. Once we have satisfied input voltage swing protection, and it maybe that none is, the next step in a signal chain is usually amplification. And in PSoC that means a PGA component. If the input signal is small and varies from 0 volts to perhaps 0.2 volts, a simple PGA with a gain of 25 would bring the maximum input signal up to 5 volts. But we cannot configure a PGA for any gain we want, there are limited values available.

For instance in this case we have 1, 2, 4, 8,16 well 24 is the closest to 25, so we'll choose that. I'll hit OK and there we have a gain stage with a gain of 25. Notice that this PGA has an external reference input, and a non-inverting input.

And if you want to use it in the simplest possible way you can reconfigure it and just say use internal VSS, not quite as accurate in some cases. I'll hit OK, and now it's a very simple device. We'll have a gain of, actually, 24. But what if the input is small, but not located near 0 volts? For instance, what if it varied from 4 to 4.2 volts?

You might think that this prevents using any gain from the PGAs since even a gain of two results in output saturation. You'd get more than what PSoC can handle, which is between 0 and 5 volts. This won't damage the chip, but you won't get any useful information out of the sensor. What we need to do is figure out a way to ignore that 4 volt offset and amplify only the 0.2 volt signal. This can be accomplished by two different methods. You can block all the DC by simply inserting a capacitor in series with the signal, that would have to be external component, because you don't have capacitors inside PSoC. But if you put a capacitor in series of the signal you create a high-pass filter. How high depends on how large a capacitor you use, and the resistance of whatever is connected to the capacitor. This works similarly to the low-pass filter we talked about. There's always some resistance and some capacitance, and they work together to create filters whether you want them to or not.

The second method works by essentially subtracting out the undesired offset before it can be amplified. Here's where the analog flexibility of PSoC could be put to good use. All you have to do is place a DAC on the schematic, configure it for a 4 volt output, and connect this to one input of the PGA. Let's try that.

In this circuit, I reconfigured the PGA to leave that external voltage reference pin available. And I connected it to the DAC, which I configured to be a 4 volt output. Notice it's 0 to 4 volts, and the initial value, the value that it assumes after power up, is 4 volts. You can change that at anytime in software simply by using the API or the function call that will write to the DAC and set the value. But here, we don't need to change it, we just need to have it at 4 volts. The PGA is going to multiply the difference between these two signals. So this input here, the analog input is at 4 volts and this is at 4 volts, the output of the PGA is 0. If the input is 4.1 volts and remember this is 4 volts right there, this is 4.1 volts, well you have 0.1 volts times a gain of 24. So the output would be, what, 2.4 volts. That's well within the range of what an ADC can handle. To complete this very basic analogue input we have added this ADC over here. And I chose the successive approximation ADC, which is fast but has more limited resolution. And by fast I mean it can go to 1 million samples per second, but the maximum resolution is 12 bits.

Besides applying gain and off et to an input signal is often useful to apply some degree of analog filtering before presenting it to an A to D converter. There are couple of reasons for this. First, the well known Shannon Nyquist sampling criteria states that frequencies exceeding half the ADC sample rate will corrupt the digital result. In practice, it's a good idea to limit the frequency content of your signal to well below that. Since no analogue filter is perfect a common rule of thumb is to limit the input frequency to just one-tenth of the ADC sample rate. So if your input signal bandwidth is one kilohertz, you must sample at at least two kilohertz, and preferably 10 kilohertz or more.

Note, we are using the term hertz synonymously with samples per second. They're not quite the same thing but this approximation will suffice for now. Second, thermal and other types of noise are always present in electronic components. Most of these noise sources are wide band, so it pays to filter out as much of them as possible, up to the limit opposed by the bandwidth as the signal you want to pass.

Let's consider that hypothetical 0 to 0.2 volt input we discussed earlier.

Besides describe it in terms of amplitude, we also need to think about its bandwidth.

Whatever that value is the bandwidth of the thermal noise is wider. And there's no point opening up the bandwidth wider than it needs to be to let the signal go through. Doing so will just let in more noise.

The decision of whether or not to implement an analog filter depends on how much noise is present in the signal bandwidth. It may be low enough to forgo this complication. But you should have a full understanding of the consequences. Once again, if this input signal contains frequencies

that are approaching half the sample rate of this ADC, you'll get a corrupted output, it'll be wrong.

For many types of sensors, like temperature sensors, the rate of change is low and you can cut out any noise above a few hertz with a simple low-pass filter.

Various topologies are available and can be implemented using the op-amps available in PSoC along with external passive components, resistors and capacitors. Online calculators are readily available that will tell you what values are needed based on desired frequency range and other factors, greatly simplifying the design.

By the way, don't just use any capacitors. They vary greatly in tolerance, drift and even linearity. Read the data sheet.

So let's review the basic analog signal processing option. The simplest possible thing you could do is just connect an analog input to an ADC like this.

This will work great assuming that analog input, from whatever sensor is attached to it, always remains between 0 volts and 5 volts, and the signal bandwidth is less than half the sample rate of this ADC.

And the noise present in the signal bandwidth is low enough so that the frequency component in the noise which exceed half the sample rate is not so large as to be a major factor.

The next step up in complexity is to amplify the signal before it's applied to the input of the ADC. And in this case I've shown a simple single ended amplifier with a gain of 24. And that will work fine as long as your signal is a small signal and near ground. Because this is going to amplify any voltages above ground on this input. That works for a wide variety of signals but not all of them.

This circuit will work to amplify a small signal that is no lower than 4 volts, and only goes a little bit above 4 volts. The DAC is applied to the Vref input of the gain stage, and the PGA only amplifies the difference between the plus and the minus input. So if they're both sitting at 4 volts, the output is 0. If the voltage rises a little bit above four, here, that difference will get multiplied by the gain of 24, and that will get applied to the ADC. So this circuit works for small signals that have a DC offset.

You can also block a DC offset with an external capacitor. Remember, when you do this, always think about the parasitic resistance and capacitances in the circuit. This input will have some resistance to ground and now you have a high-pass filter formed by this C and whatever resistance exist over here. And if you're dealing with signals in the megahertz or hundreds of megahertz range that might become important.

Only once these basic signal conditioning steps have been taken can we reliably apply the signal to one of the ADCs and PSoC. We'll talk more about that and about digital filtering in a later video.

11: Thermistor Lab, Part 1

Measuring temperature is one of the most common of all sensor applications. There are many ways to do it, but four most commonly used methods. These include the thermistor, the RTD, resistive temperature detector, thermocouples which you probably heard of, and semiconductor devices like diodes.

Each of these types of sensors has their own advantages and disadvantages. They vary not only in cost but also, importantly, in the range of temperatures that they can detect. Also, how linear the output is. And whether or not they require a separate excitation circuit or they generate a voltage on their own. Let's review the basic characteristics of thermistors. First of all, they're inexpensive. They can cost less than a dime. They're also highly sensitive. Much more so than many of the other sensor types.

They work as a variable resistance, but they're non-linear and the range of temperatures over which this linear curve works is relatively limited. For instance, in the Ametherm catalog the table stops at 150 degrees C while other types of temperature sensors can go much higher.

RTD's are also variable resistors. Typically a 100 ohm chunk of platinum. They are not very sensitive, however. The amount of resistance change per degree C is much, much lower than a thermistor which makes them harder to interface to.

On the other hand, the output is fairly linear and if you don't need the highest degree of accuracy, you can just assume a linear curve fit.

Prices are more expensive than thermistors. A few dollars. However, they can work over a much wider temperature range. For instance, one of the devices I see from US Sensor is rated from minus 50 degrees C all the way up to 500 degrees C. And remember, the thermistor from Ametherm stopped at 150 degrees C. Thermocouples, however, are a different animal. They are not variable resistors. They actually generate their own voltages.

They consist of two dissimilar metals joined together, and the types of metals used determines the type of the thermocouple. The most common being the K type thermocouple. Interestingly, thermocouples always require a second temperature measuring device at the so called cold junction. However, the cold junction can be at room temperature while the other side can be very hot, like RTD's, into the many hundreds of degrees C. Four or five hundred degrees C is typical. So they operate over a very wide temperature range. But they're a little trickier to deal with in something as simple as our thermistor.

For instance, it's quite easy to accidentally create a thermocouple on a printed circuit board, since the joining of any two dissimilar metals creates one. Usually the voltages produced by these parasitic thermocouples are small, but they can affect the accuracy of the circuit.

Diodes and over semiconductor devices can also be used to measure temperature. There'll be a voltage that is developed when the device is properly biased, and that will vary with temperature. Almost everything varies with temperature.

The advantage of diodes is they're easily included on an integrated circuit.

However, they have a limited temperature range like any semiconductor device.

We'll talk more about these four temperature measuring devices, and a few others, in later videos. But now let's get back to the business at hand. How do we interface a thermistor to a microcontroller like PSoC and do so accurately at low cost? It's an analogue interface, the voltage range is fairly large, so there's not a lot of concern about noise.

But as simple as that sounds, there are some important considerations that may not be obvious, such as how do you get the most accurate result using parts that are not overly expensive?

Here's an example of what that negative temperature coefficient curve looks like. At cold temperatures, the resistance is over 50,000 ohms. At hot temperatures, 90 or 100 degrees C, it's just a few hundred ohms, but it's a non-linear curve. So one of the problems we have to face in interfacing this to a microcontroller is to go from a non-linear curve to a linear output of temperature.

The curve you just saw can be modeled by something called a Steinhart-Hart equation. It involves three constants, a, b, and c, that are usually specified in the manufacturer's data sheets. The microcontroller needs only to measure the resistance and then calculate the temperature from this equation.

The temperature calculated by the Steinhart-Hart equation is not in degrees Farenheit, or even in degrees Celsius. It's in absolute degrees Kelvin. It's easy to use your microcontroller to add 273 to the result to get degrees Celsius from degrees Kelvin.

A little more difficult is evaluating the non-linear equation. That's best done if you include the math and floating point libraries that come with your compiler. Here's what that looks like in the code.

In addition, you have to go to Project Build Settings, then drill down to the Linker General tab, and look for Additional Libraries. And insert this m to the right of the phrase Additional Libraries. That is compiler dependent, and this compiler is the ARM GCC compiler. But it's a necessary step if you want to use the math and floating point libraries.

With those preliminaries out of the way, let's try building a thermistor interface in PSoC.

The first thing we're going to need is an analogue to digital converter. I will select the delta-sigma ADC which is the higher resolution of the two ADC's available in the PSoC chip. Let's check the default configuration.

It's set up for 16 bits at a conversion rate of 10,000 samples per second, which is probably more than enough for a thermistor.

Notice that the input voltage range is +/-1.024V. And since I've previously stated that PSoC lives between zero and five volts, that might be confusing. But the point to remember here is that when they say minus voltage, they're referring relative to the minus input of the delta-sigma ADC. They're not referring to ground. So a negative voltage would occur, as far as the ADC is concerned, any time this input with the minus sign is at a higher voltage than the input with a plus sign.

Since the thermistor is not built into the P SAR chip, we're going to have to add it as an external component to the breadboard area. But we can document that fact using the PSoC schematic in the Off-Chip Component tab. Notice it has aligned here for Sensors. We expand that. Sure enough we find a thermistor. I'll left click, drag it on to the screen, rotate it.

And take a look at the configuration. Right click > Configure. And notice the configuration is very simple and it has a default value of 25K. I'm not sure which thermistor we're going to use yet, so I'll leave that alone. But I'm going to change the name here from R_1 to Thermister to better indicate what its function is.

In our next video we'll finish hooking up this thermistor to the ADC and write some code to display the temperature indicated by the ADC on the LCD of your devkit.
: Added to Selection. Press [⌘ + S] to save as a note

12: Thermistor Lab, Part 2

So now that we have the thermister on the board, we have to use it to generate a voltage that the ADC can read. The ADC does not read resistance directly or inductance or capacitance, it only reads voltage. So somehow, we have to create a voltage with the thermister. And you might be tempted just to simply place a voltage source on the thermister and connect the other leg to ground. That will put current to the thermister, but the voltage will be exactly what the voltage you applied was. What we need to do is put it into a voltage divider circuit.

And I can easily make that by bringing in another external resistor.

Here is what that looks like. This is a simple voltage divider circuit. The 10K resistor R_1 is constant and varies very little with temperature. The thermister varies a lot with temperature. And so the voltage in between the two will change as the temperature increases or decreases. In order to connect these external components to the ADC, we're going to need to have some pins on PSoC. And these will be analog pins. It's important to note at this point that PSoC routes analog and digital signals separately. And if you want to connect an analog signal to something like an op-amp or an ATD converter, you have to use analog pins. Let's go find a couple of analog pins from the Component Catalog and assign them to a particular port and pin number using the Pins dialog. Here I've randomly selected port zero, bits zero and one and connected it through the ADC.

Notice that I included the extra step of going to the Pins tab and making the physical connection to match the name P0_0 and P0_1. To document the connection of a physical pin on PSoC to something external, we configure the pin to have an external terminal which has a blue color and wire it up to the half-bridge. Recall that an external terminal could be added to any pin simply by clicking on this External terminal checkbox in the configuration menu for the pin.

External terminals appear in color blue and are there merely to document the connection of internal PSoC components to external components, those that are not inside the chip.

Here, I've chosen to do the most obvious connection I could think of. Which is to take the negative input of the ADC and connect it to ground, which is labeled Vss on this schematic, and to connect the positive input of the ADC to the other side of the thermister.

Notice that by doing it this way, the ADC is never going to output a negative number because the input range is set up for plus or minus 1.024 volts. And since the minus terminal is at ground, the plus term was never going to get less than that and so the number read by the ADC is always going to be a positive number. So in some sense, you've lost half the resolution of your ADC, but let's not worry about that right now. In addition of that problem, this is still not the most accurate way to do the things, why?

Because well, there are several factors. First of all, the power supply is not a reference voltage. Which means that it's designed to provide a lot of electrons but it not necessarily very steady. So if the power supply varies at all, the current through this half-bridge will vary.

The value of R1 is also a critical factor. Typical resistor precisions are 5% or 1%, but for not very much more money, you can get a 0.1% resistor. Here's a couple I found on the Digi-Key website. Noticed that for 46 cents, if you buy 1,000, you can get a reasonably accurate 0.1% reference.

And we can use that to determine how much current is flowing through the half-bridge. If we know the current in the half-bridge and we know the voltage across the thermister, then we know what the resistance of the thermister is. Just simply vehicles IR equation.

But we've already used our delta-sigma ADC to measure the voltage across the thermister. How can we also measure the voltage across the 10K now precision resistor? There's only one high precision delta-sigma ADC in PSoC, but there are two SAR ADCs. And you might be tempted to use the SAR ADC to measure the voltage across a 10K resistor, but that's really a expensive resource used for a very simple purpose. A simpler method would be the use of multiplexer on the input to the ADC so we can switch between the 10k precision resistor and the thermister, and measure each at different times. That's okay to do because we don't expect the temperature to be changing very fast compared to how fast the delta-sigma ADC converter can read it.

To do this, we'll use an analog multiplexer, which is an internal component available in the Component Catalog. Let's try that.

If you watch this high speed video closely, you'll notice I made a few mistakes and went back and forth before I got it the way I wanted it. Fortunately, that's very easy to do in this development environment. Here's the configuration I ended up with for the AMux. Notice I'm using it in Differential mode. I placed the analog multiplexer here so that we can make a differential measurement on channel 0 of the the mux across the 10K precision resistor. And that will tell us how much current is flowing in the thermister, regardless of what the power supply voltage is doing. This does assume that the power supply voltage is not changing too rapidly. Because if it does by the time we make the measurement here, the current in the thermister at a later time might have actually changed. But let's assume for a moment that the power supply voltage is not changing too rapidly compared to how fast we can make our measurements, although that is a concern for accuracy.

The second differential measurement will be made when we switch the analog multiplexer to channel 1, and that will be a measurement of the voltage across the thermister.

And then by combining these two measurements, we will first determine the current through the 10K precision resistor and the thermister. Once we have the current, pi R equals V over I, we'll know what the resistance of the thermister is. Once we have the resistance of the thermister, we have to go back to that curve that shows what the temperature is versus resistance.

There are two ways to do this. You could, for instance, digitize the table, or you could calculate it mathematically using the floating point operations. PSoC, however, makes this easy because they provide a component that allows you to do this with just a few clicks. Let's take a look at that.

If we go over to the Component Catalog and expand the Thermal Management line, scroll down a little bit and you'll see something called the Thermistor Calculator.

And drag this out onto the board, and it's important to note at this point that the Thermister Calculator is not a hardware component inside of PSoC. And that's a little bit out of sequence because almost everything in this Cypress Component Catalog is in fact hardware that's inside the chip. But the Thermister Calculator is somehow different, and notice it has a red color to indicate this.

Let's take a look at the configuration for this device.

Notice there are two suggested implementations. You can calculate the temperature by an equation, or you can use a lookup table. The tradeoff there is one of speed and how much space you want to devote to the lookup table. The lookup table takes up more space, it's fast. The equation is not quite as fast, but it doesn't take as much space in code. And since temperature is generally a very slowly changing phenomenon, let's just use the equation method. Here at the top, we have a option to change the value of the reference resistor, and notice it says 10,000, which just happens to be the value I used. By the way, the resistance shown in the configuration window is not going to be automatically matched to what's shown for the thermister on the schematic. On the right side we have a temperature and resistance pull down screens that allow you to customize the calculation of the equation to match the particular thermister that you're using.

Remember that the thermister that came in the dev kit for this course has a nominal value 10K ohms at 25°C. So this is an alternative to finding the a, b, and c coefficients in a Steinhart-Hart equation. And it's a little bit easier, just go to the table, find some temperatures from the manufacturer and stick them in here and you're good to go.

Here's an example of a manufacturer's data on the resistance versus temperature curve from Ametherm, which is a large manufacturer of thermisters. And that's the type that should be included in the kit that you're using for this project. This is the Ametherm Zero Power Resistance Curve that means that there's no issue of self heating. Because when you put current through a thermister, if you put too much through it, of course, it's a resistor and it will heat itself up. By the way, self heating of the thermister is a real problem. If you put too much current through a thermister, you'll make it hot and it will measure its own temperature over that of the environment. The key is to have good thermal contact between the thermister and its environment. And of course, not to use more current that is necessary to get a good reading.

We're still not quite done with the hardware. We have to set up the input to the ADC to match the voltages that we expect from the thermister.

At room temperature, the thermister will be 10K, and that will give us 2.5 volts at P3_1. As we get hotter than room temperature, that will drop towards zero. If we go below room temperature, it's going to go above 10K, maybe as high as 50K.

At 50K, the resistor divider rule tells us that the voltage could be as high as 4.2 volts, and that doesn't take into account any variation in the power supply. But let's try to keep the analysis simple here. Let's assume that P3_1 could be as high as about 4.2 volts, and as low as well, close to 0. The input range of the ADC on PSoC is configurable. Let's take a look at the configuration.

Down here under Input options, you see that there's a pull down menu for Input range, and if I pull that down, here are my options. I can have plus or minus 1.024, 2.048, and so on.

The only one of these that goes up as high as as 4.5 volts is this one, which is plus or minus 6.144 volts. And that might be alarming because we know that the PSoC chip really only can operate between 0 and 5 and this menu option does not override that. What it means is that we're going to lose a little bit of the resolution on our ADC. But I'll select that one because it's the only one that gives me the input range that I need for the resistor values that I selected.

This configuration of the ADC is certainly confusing because we know that PSoC can only handle voltages between 0 and 5 volts. So what are they talking about when they talk about plus 6.144 volts? What they mean is that the input is going to stop at 5 volts, so the digital output is never going to reach the maximum possible value. For a 16 bit signed number, that's a little bit over 32,000. But you're not going to get there, you'll be stuck at 25,000 or so because of this limitation.

That's it for the hardware portion of this design. In the next video, we'll move on to software and see how we write code in C to operate this circuit.
: Added to Selection. Press [⌘ + S] to save as a note

13: Thermistor Lab, Part 3
Here I've refined the design a little bit. Besides changing the spelling of Thermister to Thermistor and adding a title, I've put an LCD display on the schematic because I think it's good practice to always use the LCD, it really helps with Debugging. I've also added some test points here. I've added two analog test points that we can use with our end scope or whatever sort of you have to verify what the input voltages are that the ADC reads. If you get a bad number out here, it's nice to know what's really going into the ADC so you can decide whether it's the input that's at fault or it is the configuration of the ADC or perhaps the software you are using to operate it that's at fault.

Notice I have added a few other floating test points up here at the top. I call them floating test points because they do not have a hardware input. I use these to verify operation of the circuit and to see how long certain operations take. For instance, port 0, bit 0 I could use to tell me what my overall loop time is and the other output pin I can use to determine how long the LCD or an ADC conversion is taking place, or how long it takes.

So, what about the code to operate all this?

Well in this case I've written all my code in main.c and that's true for pretty much all the projects that we will do. We'll just try code in main.c. The rare exception to that rule is if you're using interrupts, you may write code in the interrupt routines as well. But for now we'll be straight forward about it and we'll just use main.c. If I click on that tab over here, this is what my code looks like. And I'll go through that right now, so you have some idea of how I write code and how this all interacts with the circuited hand.

Start with, I think a title is always a good idea and a brief explanation as to what the code is doing. That's the first thing a new reader will look for in any piece of code. And you should always have it in there. It only takes a second.

In this case I've included the math, and floated point libraries in addition to the automatically generating code which always puts in this line at line 10 which is include project.h. But you should remember from a previous video that it's not enough to just include these two lines for math and float.h who also have to go to project.

Build Settings, go down to Linker > General and put in this m right here. If you don't put in that m, you're going to get compile errors and they're not going to be very clear about what's causing it.

I like to declare all of my variables before the line int main.c which makes them global variables. Many people in the computer science industry would say that's bad practice, but I know that if I do this. And I use the debugger, I won't have any problem about where the debugger stops and are these variables in context or not in context. I'll always be able to click on them, see what the values are and change them as necessary.

So let's start with main.c. Note I put a few blank lines up here to draw your eye to the beginning of the code.

Only a little bit of this code was automatically generated. For instance CyGlobalIntEnable is automatically generated. I left it in there, I don't think it is necessary for operation of the ADC or the LCD as I'm using them. But just in case it is necessary, I've decided to leave that in, it's harmless.

First thing I do here is, I start the delta sigma ADC, and it's a kind of a poor choice of words, I think it would have been better if they call this power up. All this does is power up that section of the chip.

If you want to actually use the ADC, another step is necessary, we'll get to that in a minute.

I have to do the same for the Mux and the LCD. Notice I do not have to do this for any of the pens in the device.

On line 35 I write the words, Thermistor Test to the LCD screen. And the reason I do that is because, sometimes due to an error in your wiring or in your code, it may occur that you actually never downloaded the code that you think you have in the development kit. So I always like to confirm that by putting a title on the first line of the LCD. And I just do that for one second or so, because after that I need the LCD to do other things.

On line 43, to draw your attention to an important part of the code, I've put a comma at line where you say start of infinite loop.

I think it's a good idea to try and space and comment your code in such a way that the major sections of the code are readily visible to the casual observer.

I've changed the default if param;; format that [INAUDIBLE] gives you to something I think it's a little bit more intuitive while 1.

And I start with a loop counter on line 48. I always have a loop counter in my code because I think it's good practice to do so, so you can stop it at any time and see how many times you've gone through the loop. Sometimes the code will get stuck or it will take a lot longer than you thought. And if you look at a loop counter. And the number is oddly low or hasn't changed at all, that tells you something's up with the code, it's just for testing purposes.

On line 49, I have LCD write counter. And I use that to only write to the LCD every so many times through the loop. And I just experiment with that number until I get a writing rate that's reasonable for the LCD. If you try to write to the LCD faster than a few hertz, you can't read it anyway and it starts to fade out at higher rates.

Now we get to the mid of it, we're done with the preliminaries. First thing you do is you have to select the AMux to differentially look at the voltage across the 10K resistor. That's just AMux 1 Select(0). And in this case, I used the default name AMux.

Here on line 54, I start the delta sigma ADC doing convergence. That's different than the start that I did previously which just powers it up. Think of it as powering up as turning the key on in any car and this is putting it into gear. We're going to start conversions on line 54. Line 57, we wait for the end of conversion and we'll get stuck here if the conversion doesn't come back and apparently that can happen sometimes. So that's one of the examples of why it might be wise to have a loop counter. I went and started this code and I didn't see what I wanted and I stopped it and I saw the loop counter was 1. That might tell me something is fishy.

Down here on line 62, I'm writing to one of those floating test points. I just write it back to 0. Notice on line 51, I wrote it to 1. Just before we start doing the conversion, I write it to a 0 here so the time that that bit spends at a value of 1 tells me how long it took to start and do a conversion on the ADC. I always check those things in case there is something fishy going on that I didn't expect.

Line 64, I just read the result, to 16 bit value and I convert it to a floating point number on line 65. So now I have the result in whatever units the ADC gives it to me in. And you can figure that out from the configuration of the ADC or you can use the API that I used on line 69, which looks at the configuration of the ADC and decides how to convert from a number to a value in milivolts.

And I put that in R_1_mv. And then I make a floating point version of the same variable, that I'm going to use a little bit later. Now, since I have the current in R1 I can, excuse me the voltage across R1 and I'm assuming that I know that the resistance is 10,000 ohms. I can convert it to current. So line 74, I actually calculate the current. In our next video, we'll complete the software review and show you how the Nscope is used in combination with those test points to tell us something about how well the design is working.

14: Thermistor Lab, Part 4


Notice when I calculate the value of current, I use a fixed number for the value of the position reference resister, and this is where the accuracy of that comes into play. If it's off, the final result will be off. Interestingly the API's that come with the thermistor component don't directly calculate the current. Instead, they use the ratio of the voltages in the two resistors. Lines 77 through 87 are almost exactly the same with the sole exception, that I select the different channel on the ADC, and I use different variables for the results, so that I have the thermistor voltage in millivolts by the time I get to line 87. One of the easiest mistakes to make in this or any other code is to get the type casting of the variables wrong. Sometimes, you'll need an unsigned integers, sometimes you need a signed integer. Floating point can solve a lot of these problems, because it doesn't have the saturation issues that are endemic to 16 or even 32 bit variables, and so I've used several floating point variables here, and I've indicated each of those variable types with the underscore f. Also take note, that I've calculated the thermistor resistants two different ways. First, I figured out what the voltage across it was in millivolts and divided by the current. And then, I use the thermistor component API which has as its inputs just relative voltages on the thermistor and I've used millivolts, but the units actually don't matter here as long as they're the same for each. This API thermistor one get resistance will be able to calculate a thermistor resistance. And I did that kind of because I wanted to check the API. So I came up with a floating point variable called thermistor RBF and I compared that to thermistor RAF that I calculated using my method and sure enough, I found out that they were exactly the same, which gave me some confidence in the API. The last piece of the loop just right to the LCD. Notice that it's embedded in the main infinite loop, and so I don't want to write to the LCD every time I go through the main infinite loop. As a matter of fact, I only write to the LCD every time it hits 1000. Then I reset the counter. That keeps the LCD from updating so fast that I can't read it. The temperature is returned from the API with units of degrees times 100, and so in order to display that with the decimal point in a more natural to typical users, I divide it by 100. I write out the first two digits, I write a decimal point, write out the last two digits, using the remainder function and that's it. That's basically what the code looks like. And it's about 131 lines here which is a lot, but probably a third of that is comments in whitespace. And then, another big chunk of it are things that I did just to make the code a little bit more readable and to test it carefully. For instance, I did not have to calculate the current directly using the floating points. I could have cut this back considerably. For learning purposes, we're not going to provide the exact code listing here. You could copy it off the screen if you want, but you're not going to learn much if you just copy it off the screen. I'm hoping that you will get the general idea from this description and looking at a few key lines of code, and then figure out how to do it your own. Let's take a look again at those test points that I put on the design. In the infinite loop, I write a one two P0 1 and then later I write a zero to it. And the time in-between happens to be the time that it took to start the Delta Sigma ADC, and then to finish the conversion. And here's what it looks like on the nScope. I just ran a couple of wires over to channel one and channel two of the nScope and the red trace here shows me the time that it takes to write to the LCD. Remember, we write to the LCD only every one thousandth time through the loop, and it takes longer to write to the LCD than it does to do everything else in the loop. Which is indicated by the green trays. But wait, there's even more information available from these two simple GPIO pins. If we trigger on and zoom in on the green trays, we could see that the ADC conversion time is approximately 122 microseconds. I know that because the code writes it to a one, just before it starts the ADC and it doesn't write it to a zero until it's done with the conversion. If we watch this trace live, we can see that the conversion time is very consistent. That's not true for all ADC converters. So there's quite a bit of information you can get out of a system just by looking at a few GPIO pins with your nScope. Here's what the project looks like when I built it. There's a lot of wires there. Most of them are for that LCD display. The thermistor and the precision resistor up there in the upper right hand corner. Here's a close up. I hope this has been an interesting and useful lab. And that you learned not only something about thermistors and interfacing sensors to a piece our chip, but you also learned a little bit about debug techniques that can come in handy in many projects.

Week 2 Online Articles
Handbook of Modern Sensors by Jacob Fraden, Fifth Edition. Springer Scence+Business Media, LLC ISBN 978-3-319-19302-1 for hardcover book. ISBN 978-3-319-19303-8 for ebook. Purchase textbook from this web site:
www.springer.com/us/book/9783319193021
.

Note: The above book is strongly encouraged, but not required for our Coursera Specialization. However, CU Master's degree students are required to obtain this book for this class.

Pages to read for this module:
Chapter 6 pages 225-238 6.4 Analog-to-Digital Converter

Load the latest version of Cypress PSoC Creator Software and explore it. Latest version as of Sept 2, 2018 is 4.2. Download from Cypress Semiconductor web site via this link:
http://www.cypress.com/products/psoc-creator-integrated-design-environment-ide

AN77759 - Getting Started with PSoC® 5LP (download from Cypress Semiconductor web site via this link:
http://www.cypress.com/documentation/application-notes/an77759-getting-started-psoc-5lp
